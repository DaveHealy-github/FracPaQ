function [ Y, X, I ] = getConnectivity(traces, segments, xMax, yMax) 

%% Copyright
% Permission is hereby granted, free of charge, to any person obtaining a
% copy of this software and associated documentation files (the
% "Software"), to deal in the Software without restriction, including
% without limitation the rights to use, copy, modify, merge, publish,
% distribute, sublicense, and/or sell copies of the Software, and to permit
% persons to whom the Software is furnished to do so, subject to the
% following conditions:
% 
% The above copyright notice and this permission notice shall be included
% in all copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
% NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
% OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
% USE OR OTHER DEALINGS IN THE SOFTWARE.

Y = 0 ; 
X = 0 ; 
I = size(traces,2) * 2 ; 

segments = segments(~any(isnan(segments),2),:) ; 

nInt = 0 ; 

for i = 1:size(segments,1) 
    
%     disp(['Segment: ', num2str(i)]) ; 
    
    %   round the coordinates to the nearest whole pixel - good enough! 
%     scanXY = [ round(segments(i, 1)), round(segments(i, 2)), ...
%                 round(segments(i, 3)), round(segments(i, 4)) ] ; 
    scanXY = [ segments(i, 1), segments(i, 2), ...
              segments(i, 3), segments(i, 4) ] ; 
    
    if any(isnan(scanXY))
        disp('Bad data in segments') ; 
        
    else
        
        intScan = lineSegmentIntersect(scanXY, segments) ; 

        for j = i+1:size(segments,1) 

            %   check that the scan line is not the same as the matched line 
            if intScan.coincAdjacencyMatrix(1, j) < 1 

                %   is there an intersection? 
                if intScan.intAdjacencyMatrix(1, j) > 0

                    nInt = nInt + 1 ; 

                    %   get coords of intersection 
%                     xint(nInt) = round(intScan.intMatrixX(1, j)) ; 
%                     yint(nInt) = round(intScan.intMatrixY(1, j)) ; 
                    xint(nInt) = intScan.intMatrixX(1, j) ; 
                    yint(nInt) = intScan.intMatrixY(1, j) ; 

                    %   if this intersection point is also the end of either line  
                    if ( xint(nInt) == scanXY(1) && yint(nInt) == scanXY(2) ) 
                        Y = Y + 1 ; 
                        fint(nInt) = 'Y' ; 
                    elseif ( xint(nInt) == scanXY(3) && yint(nInt) == scanXY(4) )
                        Y = Y + 1 ; 
                        fint(nInt) = 'Y' ; 
%                    elseif ( xint(nInt) == round(segments(j, 1)) && yint(nInt) == round(segments(j, 2)) )
                    elseif ( xint(nInt) == segments(j, 1) && yint(nInt) == segments(j, 2) )
                        Y = Y + 1 ; 
                        fint(nInt) = 'Y' ; 
%                    elseif ( xint(nInt) == round(segments(j, 3)) && yint(nInt) == round(segments(j, 4)) )
                    elseif ( xint(nInt) == segments(j, 3) && yint(nInt) == segments(j, 4) )
                        Y = Y + 1 ; 
                        fint(nInt) = 'Y' ; 
                    else 
                        X = X + 1 ; 
                        fint(nInt) = 'X' ; 
                    end ; 

                end ; 

            end ;

        end ; 

    end ; 
    
end ; 

disp('Before intersection adjustment:') ; 
disp(['I: ', num2str(I)]) ; 
disp(['Y: ', num2str(Y)]) ; 
disp(['X: ', num2str(X)]) ; 
%   ONLY run this for when the number of traces < number segments 
%   - i.e. NOT for maps generated by image analysis/Hough transform  
%   correct for extra 'Y' nodes when a trace 'kinks' on intersecting another
%   segment; this is currently 3 'Y' nodes, but should be 1 'X' node
if max(size(traces)) < max(size(segments))

    for i = 1:nInt 

        if ~isnan(xint(i)) && fint(i) == 'Y'

            ix = find(xint == xint(i), nInt) ; 
            iy = find(yint == yint(i), nInt) ; 

            if length(ix) > 1 && length(iy) > 1  

                Y = Y - length(ix) ; 
                X = X + 1 ; 

                %   make sure we only deal with each duplicate once 
                xint(ix) = NaN ; 
                yint(iy) = NaN ; 

            end ;

        end ; 

    end ; 
    
end ;

disp('After intersection adjustment:') ; 
disp(['I: ', num2str(I)]) ; 
disp(['Y: ', num2str(Y)]) ; 
disp(['X: ', num2str(X)]) ; 

%   also remove any I points that lie on the edge of the area; censoring 
xMaxr = round(xMax) ; 
yMaxr = round(yMax) ; 
for i = 1:size(traces,2) 

    maxNode = traces(i).nNodes ; 
    
    if round(traces(i).Node(1).x) == 0 || round(traces(i).Node(1).x) == xMaxr 
        I = I - 1 ; 
    elseif round(traces(i).Node(1).y) == 0 || round(traces(i).Node(1).y) == yMaxr
        I = I - 1 ; 
    elseif round(traces(i).Node(maxNode).x) == 0 || round(traces(i).Node(maxNode).x) == xMaxr
        I = I - 1 ; 
    elseif round(traces(i).Node(maxNode).y) == 0 || round(traces(i).Node(maxNode).y) == yMaxr
        I = I - 1 ; 
    else 
        continue ; 
    end ; 
        
end ; 

disp('After censoring:') ; 
disp(['I: ', num2str(I)]) ; 
disp(['Y: ', num2str(Y)]) ; 
disp(['X: ', num2str(X)]) ; 

